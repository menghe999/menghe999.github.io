{"meta":{"title":"小孟的个人博客","subtitle":"一枚技术宅","description":"","author":null,"url":"http://yoursite.com","root":"/"},"pages":[{"title":"第一篇博客","date":"2019-12-08T02:08:13.000Z","updated":"2020-08-15T00:03:38.513Z","comments":true,"path":"null/2019-12-08-hello-this-a-test.html","permalink":"http://yoursite.com/null/2019-12-08-hello-this-a-test.html","excerpt":"","text":"经历一天的摸索，成功搭建hexo+coding博客框架，并更换yilia主题，设置点击小心心功能，本博客用于记录生活和工作中的采坑记录。"},{"title":"C语言之位操作","date":"2020-01-19T12:38:03.000Z","updated":"2020-02-12T05:14:05.610Z","comments":true,"path":"null/2020-01-19-bit-operator-1.html","permalink":"http://yoursite.com/null/2020-01-19-bit-operator-1.html","excerpt":"在嵌入式开发过程中，位操作也是最基本的要求，大多数嵌入式设备的内存紧张，需要对位操作来节省内存空间，让我们来熟悉一下位操作","text":"在嵌入式开发过程中，位操作也是最基本的要求，大多数嵌入式设备的内存紧张，需要对位操作来节省内存空间，让我们来熟悉一下位操作 通过移位运算获取单字节数据 1#define GET_LOW_BYTE0(x) ((x&gt;&gt; 0)&amp;0x000000ff) &#x2F;&#x2F;第0个字节&#96;2#define GET_LOW_BYTE1(x) ((x&gt;&gt; 8)&amp;0x000000ff) &#x2F;&#x2F;第1个字节&#96;3#define GET_LOW_BYTE2(x) ((x&gt;&gt; 16)&amp;0x000000ff) &#x2F;&#x2F;第2个字节&#96;4#define GET_LOW_BYTE3(x) ((x&gt;&gt; 24)&amp;0x000000ff) &#x2F;&#x2F;第3个字节&#96;56int main(void)7&#123;8 unsigned int a &#x3D; 0x87654321; &#x2F;&#x2F;4字节数据&#96;9 printf(&quot;0x%x的第0个字节为；0x%x\\n&quot;, a,GET_LOW_BYTE0(a) );10 printf(&quot;0x%x的第1个字节为；0x%x\\n&quot;, a,GET_LOW_BYTE1(a) );11 printf(&quot;0x%x的第2个字节为；0x%x\\n&quot;, a,GET_LOW_BYTE2(a) );12 printf(&quot;0x%x的第3个字节为；0x%x\\n&quot;, a,GET_LOW_BYTE3(a) );1314&#125; 使用gcc编译链接可执行文件，运行结果如下："}],"posts":[{"title":"什么是抽象类、什么是接口？","slug":"Abstract-Interface","date":"2020-08-14T23:57:53.000Z","updated":"2020-08-14T23:59:53.511Z","comments":true,"path":"/blog/2020/08/15/Abstract-Interface/","link":"","permalink":"http://yoursite.com/blog/2020/08/15/Abstract-Interface/","excerpt":"Java中的抽象类和接口","text":"Java中的抽象类和接口 抽象类什么是抽象类？ 在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。 抽象类的特点 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。 接口什么是接口，对比类进行解释 ？ 接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。 接口与类相似点： 一个接口可以有多个方法。 接口文件保存在 .java 结尾的文件中，文件名使用接口名。 接口的字节码文件保存在 .class 结尾的文件中。 接口相应的字节码文件必须在与包名称相匹配的目录结构中。 接口与类的区别： 接口不能用于实例化对象。 接口没有构造方法。 接口中所有的方法必须是抽象方法。 接口不能包含成员变量，除了 static 和 final 变量。 接口不是被类继承了，而是要被类实现。 接口支持多继承。 接口特性 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。 抽象类和接口的区别 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。 一个类只能继承一个抽象类，而一个类却可以实现多个接口。 接口的继承 单继承：一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。 多继承：在Java中，类的多继承是不合法，但接口允许多继承。 参考菜鸟教程","categories":[],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"什么是面向对象编程？","slug":"oop","date":"2020-08-14T23:52:32.000Z","updated":"2020-08-14T23:59:51.365Z","comments":true,"path":"/blog/2020/08/15/oop/","link":"","permalink":"http://yoursite.com/blog/2020/08/15/oop/","excerpt":"Java面向对象三大特征，封装、继承、多态","text":"Java面向对象三大特征，封装、继承、多态 1、封装在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。 封装的特点： 良好的封装能够减少耦合。 类内部的结构可以自由修改。 可以对成员变量进行更精确的控制。 隐藏信息，实现细节。 2、继承Java是单继承方式，不支持多继承，但是支持多重继承。 继承的三大特征： 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是 父类中的私有属性和方法子类是无法访问，只是拥有。 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。（重写方法）。 3、多态多态是同一个行为具有多个不同表现形式或形态的能力。 多态的优点： 消除类型之间的耦合关系 可替换性 可扩充性 接口性 灵活性 简化性 多态存在的必要条件： 存在继承 子类重写父类方法 由父类指向子类对象","categories":[],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"Ruoyi-vue开源项目 部署过程记录","slug":"ruoyi","date":"2020-07-28T07:49:51.000Z","updated":"2020-07-28T12:29:16.765Z","comments":true,"path":"/blog/2020/07/28/ruoyi/","link":"","permalink":"http://yoursite.com/blog/2020/07/28/ruoyi/","excerpt":"基于SpringBoot、Spring Security、Jwt、Vue的前后端分离的后台管理系统","text":"基于SpringBoot、Spring Security、Jwt、Vue的前后端分离的后台管理系统 1、部署环境基础 JDK &gt;= 1.8 (推荐1.8版本) Mysql &gt;= 5.5.0 (推荐5.7版本) Redis &gt;= 3.0 Maven &gt;= 3.0 Node &gt;= 10 Nginx 本实验部署在Centos 7的虚拟机上，已经安装好上述环境。 确保以上环境部署成功，再继续下面的步骤。 2、克隆 Ruoyi-vue 项目到本地1git clone https:&#x2F;&#x2F;gitee.com&#x2F;y_project&#x2F;RuoYi-Vue.git 项目结构如下： 1└── RuoYi-Vue2 ├── bin3 ├── doc4 ├── LICENSE5 ├── pom.xml6 ├── README.md7 ├── ruoyi-admin8 ├── ruoyi-common9 ├── ruoyi-framework10 ├── ruoyi-generator11 ├── ruoyi-quartz12 ├── ruoyi-system13 ├── ruoyi-ui14 ├── ry.sh15 └── sql 3、修改必要配置下面所有的操作都是在ruoyi-admin文件夹下 创建数据库ry-vue并导入数据脚本ry_20191008.sql，quartz.sql 修改数据库连接编辑resources目录下的application-druid.yml 1url: 服务器地址2username: 账号3password: 密码 开发环境配置编辑resources目录下的application.yml 1port: 端口2context-path: 部署路径 填写Redis地址和密码 1redis:2 # 地址3 host: localhost4 # 端口，默认为63795 port: 63796 # 密码7 password: 日志配置，修改logback.xml文件，配置本地路径 1&lt;!-- 日志存放路径 --&gt;2&lt;property name&#x3D;&quot;log.path&quot; value&#x3D;&quot;&#x2F;home&#x2F;ruoyi&#x2F;logs&quot; &#x2F;&gt; 再给logback.xml添加字符集 charset 1&lt;pattern&gt; ......&lt;&#x2F;pattern&gt; 2&lt;charset&gt;UTF-8&lt;&#x2F;charset&gt; 4、上传至服务器打包（SFTP） 前端打包(前端文件压缩一下，再上传) 上传完成先安装依赖 1# 强烈建议不要用直接使用 cnpm 安装，会有各种诡异的 bug，可以通过重新指定 registry 来解决 npm 安装速度慢的问题。2npm install --unsage-perm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org 打包 1npm rum build:prod 会生成dist目录，包含目录如下 1├── favicon.ico2├── index.html3├── robots.txt4└── static 后端打包（jar） 在后端项目主目录使用命令 1mvn package 得到target目录，包含jar包。（注意备份jar包） 开始部署 先部署前端，首先配置ngnix，修改/usr/local/nginx/conf中的nginx.conf文件。修改成如下部分 1user root;#修改成root用户2|3|4|5 location &#x2F; &#123;6 root &#x2F;home&#x2F;menghe&#x2F;file&#x2F;ruoyi-ui&#x2F;dist; #前端文件位置7 index index.html index.htm;8 &#125;9 10 #修改转发路径,关联前后台11 location &#x2F;prod-api&#x2F; &#123; 12 proxy_set_header Host $http_host;13 proxy_set_header X-Real-IP $remote_addr;14 proxy_set_header REMOTE-HOST $remote_addr;15 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;16 proxy_pass http:&#x2F;&#x2F;192.168.0.201:8080&#x2F;;#后端地址17 &#125; 注意修改完成更新nginx 1&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reload 然后后端部署 1nohup java -jar ruoyi-admin.jar &amp; 5、启动系统 使用浏览器访问服务器IP地址，正常情况你就可以登陆了。 6、相关链接官方文档 保姆教学","categories":[],"tags":[{"name":"项目部署","slug":"项目部署","permalink":"http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Springboot","slug":"Springboot","permalink":"http://yoursite.com/tags/Springboot/"}]},{"title":"啥？你想diy一个智能音箱，来吧","slug":"raspberry-diy","date":"2020-02-12T07:49:51.000Z","updated":"2020-12-19T10:02:02.007Z","comments":true,"path":"/blog/2020/02/12/raspberry-diy/","link":"","permalink":"http://yoursite.com/blog/2020/02/12/raspberry-diy/","excerpt":"没错，这是智zhang语音助手","text":"没错，这是智zhang语音助手 本系统基于自美系统二次开发，添加连接EMQ服务器，语音远程控制LED（Nodemcu），当然也可以扩展控制更多的设备，只需要将下位机设备连接到EMQ服务器即可。 由于使用自美系统，需要配套的驱动板官方文档有相关链接。（有兴趣的同学可以了解一下 悟空项目 ，也是一个开源智能音箱项目） 自美系统已经将基础的语音交互框架做好，支持自定义唤醒词（snowboy平台），不过有一点需要了解，如果想使用自美系统，需要购买其专用驱动板，用来驱动扬声器和麦克风。如下图 这不是广告哈 对了，有一点需要主要，对于这类智能语音交互系统，麦克风的质量真的很重要，不然都唤醒不了，那就尴尬了。 开机界面如下（界面还是很简洁的） 这里主要介绍一下，二次开发插件的过程，使用Python语言，代码很简单。 自美文档详细介绍了如何添加插件（这里直接上代码） 1# encoding: utf-82import paho.mqtt.client as mqtt34from plugin import Plugin56HOST = \"47.98.xxx.58\" #EMQ服务器地址7PORT = 1883 #端口固定18838MQTT_ID=\"Client_Test\" #自定义客户端910class Test(Plugin):11 def start(self,name): 12 client = mqtt.Client(MQTT_ID)13 client.connect(HOST, PORT, 60)14 if name[\"data\"].count(\"开\") &gt;=1:15 client.publish(\"LED\",\"1024\",2) # 发布一个主题为'LED'16 return &#123;'state':True,'data': \"主人，灯已打开\" ,'msg':'','stop':True&#125; 17 elif name[\"data\"].count(\"关\") &gt;=1:18 client.publish(\"LED\",\"0\",2) # 发布一个主题为'LED'19 return &#123;'state':True,'data': \"主人，灯已关闭\" ,'msg':'','stop':True&#125; 20 else:21 return &#123;'state':True,'data': \"没有执行任何操作\" ,'msg':'','stop':True&#125; 演示视频如下： 语音控制Nodemcu上的一个LED 附加Nodemcu的代码（使用arduino平台开发） 1#include &lt;ESP8266WiFi.h&gt;2#include &lt;PubSubClient.h&gt;3#include &lt;math.h&gt;4int pinLED = D2;56const char* ssid = \"123\";//连接的路由器的名字7const char* password = \"12345678\";//连接的路由器的密码8const char* mqtt_server = \"47.98.xxx.58\";//服务器的地址 9const int port=1883;//服务器端口号1011WiFiClient espClient;12PubSubClient client(espClient);1314int light=1024;//led的亮度值1516void setup_wifi() &#123;//自动连WIFI接入网络17 delay(10);18 WiFi.begin(ssid, password);19 while (WiFi.status() != WL_CONNECTED) &#123;20 delay(500);21 Serial.print(\"hello 8266\\n\");22 Serial.print(\"...\");23 &#125;24&#125;2526void callback(char* topic, byte* payload, unsigned int length) &#123;//用于接收数据27 //将char* 转换为int28 int l=0;29 int p=1;30 for (int i = length-1; i &gt;=0; i--) &#123;31 l+=(int)((char)payload[i]-'0')*p;32 p*=10;33 &#125;34 light=l;//赋值给light35 Serial.println(l);3637&#125;3839void reconnect() &#123;//等待，直到连接上服务器40 while (!client.connected()) &#123;//如果没有连接上41 if (client.connect(\"nodemcu\")+random(999999999)) &#123;//接入时的用户名，尽量取一个很不常用的用户名42 client.subscribe(\"LED\");//接收外来的数据时的intopic43 &#125; else &#123;44 Serial.print(\"failed, rc=\");//连接失败45 Serial.print(client.state());//重新连接46 Serial.println(\" try again in 5 seconds\");//延时5秒后重新连接47 delay(5000);48 &#125;49 &#125;50&#125;515253void setup() &#123;//初始化程序，只运行一遍54 pinMode(LED_BUILTIN, OUTPUT);55 Serial.begin(115200);//设置串口波特率（与烧写用波特率不是一个概念）56 setup_wifi();//自动连WIFI接入网络57 client.setServer(mqtt_server, port);//端口号58 client.setCallback(callback); //用于接收服务器接收的数据59&#125;60616263void loop() &#123;//主循环64 reconnect();//确保连上服务器，否则一直等待。65 client.loop();//MUC接收数据的主循环函数。66 analogWrite(LED_BUILTIN,1024-light);//设置led亮度67&#125;6869//代码是网上下载的，找不到作者了，如有侵权联系删除，谢谢 源码会上传到Github（有需要自行下载） 欢迎知乎私信 小孟同学呀","categories":[],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"http://yoursite.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"diy","slug":"diy","permalink":"http://yoursite.com/tags/diy/"},{"name":"语音交互","slug":"语音交互","permalink":"http://yoursite.com/tags/%E8%AF%AD%E9%9F%B3%E4%BA%A4%E4%BA%92/"}]},{"title":"在Centos上安装docker，部署mysql数据库","slug":"docker-mysql","date":"2020-02-12T04:48:14.000Z","updated":"2020-02-12T05:06:29.411Z","comments":true,"path":"/blog/2020/02/12/docker-mysql/","link":"","permalink":"http://yoursite.com/blog/2020/02/12/docker-mysql/","excerpt":"何为docker？ Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。","text":"何为docker？ Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 本机环境24小时不关机的Centos 7 CentOS Linux release 7.7.1908 (Core) 如何安装？1、首先查看仓库中所有docker版本yum list docker-ce --showduplicates | sort -r 2、输入命令安装（前提是本机没有其他版本docker）sudo yum install docker-ce 3、等待几分钟完成之后，查询是否安装成功docker -v 常用docker 命令拉取镜像 docker pull xxx xxx是镜像名 查看本地docker镜像 docker images 查看docker运行的进程docker ps 停止某一进程 docker stop XXX(XXX 是 CONTAINER ID ) 下面演示docker 安装 mysql1、查询docker仓库中mysql的版本docker search mysql 2、导入mysql镜像docker pull mysql 等待完成 3、启动mysql数据库docker run --name mysql_demo -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql 其中123465是管理员密码，请自行定义。 4、使用命令进入docker mysql docker exec -it 627f1857db41 /bin/bash 627f1857db41是CONTAINER ID 5、登陆mysql使用命令 mysql -uroot -p 6、输入密码123456 如果你能看到一下结果，就证明你已经成功在docker上部署mysql数据库了。 12[root@izbp1bfxfdyulbdgtdansvz ~]# docker exec -it 627f1857db41 &#x2F;bin&#x2F;bash3root@627f1857db41:&#x2F;# mysql -uroot -p4Enter password:5Welcome to the MySQL monitor. Commands end with ; or \\g.6Your MySQL connection id is 147Server version: 8.0.19 MySQL Community Server - GPL8Copyright (c) 2000, 2020, Oracle and&#x2F;or its affiliates. All rights reserved.9Oracle is a registered trademark of Oracle Corporation and&#x2F;or its10affiliates. Other names may be trademarks of their respective11owners.12Type &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement.13mysql&gt; show databases;14+--------------------+15| Database |16+--------------------+17| demo |18| information_schema |19| mysql |20| performance_schema |21| sys |22+--------------------+235 rows in set (0.00 sec)24mysql&gt; exit25Bye26root@627f1857db41:&#x2F;# exit27[root@izbp1bfxfdyulbdgtdansvz ~]#28[root@izbp1bfxfdyulbdgtdansvz ~]# 使用exit 退出mysql和docker","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]}]}